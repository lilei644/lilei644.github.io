{"meta":{"title":"LiLei's blogs","subtitle":null,"description":"心之所向  素履以往","author":"LiLei","url":"https://lilei644.github.io"},"pages":[],"posts":[{"title":"Android Studo jni开发入门——看我就够了!","slug":"jni开发入门——看我就够了","date":"2017-03-31T12:44:52.000Z","updated":"2018-01-04T03:11:57.097Z","comments":true,"path":"2017/03/31/jni开发入门——看我就够了/","link":"","permalink":"https://lilei644.github.io/2017/03/31/jni开发入门——看我就够了/","excerpt":"此贴记录一下Android Studio 进行jni开发的基础配置以及入门教程，想当初使用eclipse配置ndk环境都难，现在基本都向AS转型，特此给需要帮助的新手村的同学们少走弯路☺ 一、环境配置主要需要配置的就是NDK（Native Development Kit），现在Android studio很便利，可以一键下载：file → setting → 按截图找到如下路径 → 选择NDK → 确定应用下载 安装完成以后就可以开撸了","text":"此贴记录一下Android Studio 进行jni开发的基础配置以及入门教程，想当初使用eclipse配置ndk环境都难，现在基本都向AS转型，特此给需要帮助的新手村的同学们少走弯路☺ 一、环境配置主要需要配置的就是NDK（Native Development Kit），现在Android studio很便利，可以一键下载：file → setting → 按截图找到如下路径 → 选择NDK → 确定应用下载 安装完成以后就可以开撸了 二、jni hello world!1. 新建一个项目 新建一个app，测试jni开发 2.设置支持jni 打开gradle.properties，添加： 1android.useDeprecatedNdk=true 打开local.properties，添加： 1ndk.dir=NDK的路径 最后打开app内build.gradle，在android/defaultConfig下面添加ndk配置 1234567891011121314151617181920212223242526272829303132333435apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 25 buildToolsVersion &quot;25.0.0&quot; defaultConfig &#123; applicationId &quot;com.lilei.testjni&quot; minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; ndk &#123; moduleName &quot;JNISample&quot; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) compile &apos;com.android.support:appcompat-v7:25.3.1&apos; compile &apos;com.android.support.constraint:constraint-layout:1.0.0-alpha8&apos; testCompile &apos;junit:junit:4.12&apos;&#125; moduleName 表示编译出的so文件的名字 3.新建java访问c层的接口类 创建一个Jni的工具类，并定义接口函数，函数关键字用native（static用不用均可） 1234567891011package com.lilei.testjni;/** * Created by lilei on 2017/3/29. */public class JniUtils &#123; public static native String getJniString();&#125; getJniString()方法即要与C层的交互的函数 4.生成头文件 “make-project”编译完成 打开终端，运行12cd app/build/intermediates/classes/debug/javah com.lilei.testjni.JniUtils 运行成功之后打开app/build/intermediates/classes/debug/ 即可找到编译出的头文件”com_lilei_testjni_JniUtils.h”，不难发现头文件名是有原报名+类名组成 5.创建jni开发的文件夹 点击app文件夹，New → Folder → JNI Folder, 选择在main文件夹下即可，生成成功后main目录下会出现一个jni的文件夹 找到刚才生成到头文件，复制到jni文件夹下（记得关闭刚才使用的终端，否则无法复制） 头文件有了，现在在jni目录下创建一个C++文件用于开发使用，命名与头文件相同 编写C++文件中定义函数的代码 1234567#include &quot;com_lilei_testjni_JniUtils.h&quot;JNIEXPORT jstring JNICALL Java_com_lilei_testjni_JniUtils_getJniString (JNIEnv *env, jclass) &#123; // new 一个字符串，返回Hello World return env -&gt; NewStringUTF(&quot;Hello World&quot;);&#125; 6.java层加载so 回到JniUtils，加上 123static &#123; System.loadLibrary(&quot;JNISample&quot;); &#125; 7.运行Run 调用jni的函数 1234567891011121314151617package com.lilei.testjni;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.i(&quot;Jni&quot;, JniUtils.getJniString()); &#125;&#125; 至此就成功运行出jni的Hello World了 三、生成so文件 前文介绍如何运行C++程序，但是实际开发中大多是封装编译出so文件后进行开发，就类似java里面的jar包 1.配置NDK环境变量 找到Android Studio安装的NDK包的文件目录（E:\\AndroidStudioSDK\\SDK\\ndk-bundle），添加到系统的环境变量中 2.新建mk文件 在jni目录下新建Android.mk 1234567LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := JNISampleLOCAL_SRC_FILES := com_lilei_testjni_JniUtils.cppinclude $(BUILD_SHARED_LIBRARY) 在jni目录下新建Application.mk文件 1234APP_STL := gnustl_staticAPP_CPPFLAGS := -frtti -fexceptions -std=c++0xAPP_ABI := armeabi-v7aAPP_PLATFORM := android-18 3.编译生成so 打开终端cd到jni目录下 调用ndk-build开始编译so 1ndk-build 运行无误的话会如图所示 运行成功之后即会看到main文件夹下多了libs和obj的文件夹，里面就是生成的各种CPU的so文件 libs和obj里面都有so文件，两者的区别google给出的解释是：As part of the build process, the files in the libs folder have been stripped of symbols and debugging information. So you’ll want to keep two copies of each of your .so files: One from the libs folder to install on the Android device, and one from the obj folder to install for GDB to get symbols from.也就是说，libs目录下生成的库是剥离了符号表与调试信息的，而obj下的库是带有调试信息的。 至此jni的开发入门已完成 四、jni常用类型和方法 jni也有自己特定的语法，完成入门教程的同学想进阶的话可以查看这篇博客，该博主汇总收集了jni的常用方法和类型","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://lilei644.github.io/tags/Android/"},{"name":"jni","slug":"jni","permalink":"https://lilei644.github.io/tags/jni/"}]},{"title":"记录一次GreenDao3.x踏坑之旅","slug":"记录一次GreenDao3-x踏坑之旅","date":"2017-02-05T06:27:54.000Z","updated":"2018-01-04T03:15:16.879Z","comments":true,"path":"2017/02/05/记录一次GreenDao3-x踏坑之旅/","link":"","permalink":"https://lilei644.github.io/2017/02/05/记录一次GreenDao3-x踏坑之旅/","excerpt":"","text":"最近公司开发新项目，于是便使用GreenDao做数据持久化，毕竟第一次正式在项目中使用，特此记录下使用中碰到的两个坑。 一.前言公司准备开发一个新项目，由于项目中需要用到数据持久化，所以便开始挑选合适的方案，目前最稳定的当然是sqlite了，但是近闻realm比较火，使用起来也比较方便，所以决定大胆尝试一次。但是最终集成开发后用了两天便弃坑了，后来才发现原来网上也有大部分相同感受的人。后来决定还是重新使用稳定的sqlite方案，就开始选择开源的ORM类库，GreenDao无论是在效率还是使用上都是较优的，所以选择了它。看了下github的主页原来版本已经到3.x的时代了，网上查阅了下相关教程原来集成和使用上也变得更便捷，于是拿起键盘就开始干了！ 二.踏坑之旅 GreenDao3.x的具体使用我就不介绍了，网上也有很多相关教程，特此记录项目开发中碰到的两个坑 1.一定要有一个类型为Long的主键如果你的对象需要用到update，那么建议你一定要设置一个Long型的主键 是Long不是long 12@Id(autoincrement = true)private Long id; // 设置id为主键并自增长 因为如果要update必须要查询出对象，然后通过set方法设置参数的值，最后通过dao.update(bean); 方法更新，但是这个对象必须要有一个主键，且如果为自增长的话则必须为Long. 2.令人又爱又恨的查询缓存项目中有一个需求是需要先将一张表修改后查询出最新集合对象，但是当我先update表之后，调用query方法查询，当场就懵逼了，竟然不是最新的数据，调取出数据库的db文件查看update已经成功，可是为什么就是查询出的结果不对呢，被这个问题困扰了一个下午。 几经波折，又细细的看了下类库的源码，各种谷歌百度，终于找到了问题的原因（= =！也可能是第一用，太小白了！），原来GreenDao 的Session会将第一次query的结果缓存起来，后面如果调用相同的查询语句则会直接显示缓存的对象（当我发现这个原因之后内心的OS是，原来高效的查询不是这么容易办到的，果然人生处处是坑！！！） 找到原因之后要解决问题就简单了，方法有两种：（1）在每次查询更新的表之前调用一下清除缓存1mDaoSession.clear(); // 清除缓存 （2）初始化session的时候直接使用无缓存模式1mDaoSession = mDaoMaster.newSession(IdentityScopeType.None); 三.总结 获取第一次使用GreenDao3.x各方面相关方法没掌握才入坑，特此记录下来方便以后出现同样问题的同学查阅","categories":[],"tags":[{"name":"GreenDao","slug":"GreenDao","permalink":"https://lilei644.github.io/tags/GreenDao/"},{"name":"sqlite","slug":"sqlite","permalink":"https://lilei644.github.io/tags/sqlite/"}]},{"title":"MySql性能优化——基础篇","slug":"MySql性能优化——基础篇","date":"2016-12-31T09:48:56.000Z","updated":"2018-01-04T03:12:37.066Z","comments":true,"path":"2016/12/31/MySql性能优化——基础篇/","link":"","permalink":"https://lilei644.github.io/2016/12/31/MySql性能优化——基础篇/","excerpt":"记录工作中累计的sql正确的使用方式，从sql语句上优化mysql性能 1.分页mysql的limit语法跟sqlserver的top比起来真的是好用太多，特别是在分页上基本是想要什么就取什么，那么当单标数据量达到百万以上时应该怎样正确的使用分页呢？ 1SELECT * FROM table ORDER BY id LIMIT 1000000, 10; 这是大部分分页的方式，然而当数据量超过百万甚至千万时耗时大概十几秒甚至几十秒！ 1SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 这样的话可以优化只0.x秒内 1SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010; 比上面那句，还要再快5至10倍","text":"记录工作中累计的sql正确的使用方式，从sql语句上优化mysql性能 1.分页mysql的limit语法跟sqlserver的top比起来真的是好用太多，特别是在分页上基本是想要什么就取什么，那么当单标数据量达到百万以上时应该怎样正确的使用分页呢？ 1SELECT * FROM table ORDER BY id LIMIT 1000000, 10; 这是大部分分页的方式，然而当数据量超过百万甚至千万时耗时大概十几秒甚至几十秒！ 1SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 这样的话可以优化只0.x秒内 1SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010; 比上面那句，还要再快5至10倍 2.尽量不在sql中使用函数尽量不要在sql中使用函数，因为这样缓存是无效的 1SELECT username FROM user WHERE signup_date &gt;= CURDATE() 3.为你的搜索字段建立索引为你的搜索字段以及连接查询的关联字段创建索引可以大大提高搜索效率，不过如果你的搜索字段是varchar并且使用like模糊查询就没有必要使用索引了。 4.当判断是否存在时使用LIMIT 1如果在表中只为了判断是否存在请使用limit 1,例如用户注册判断是否存在同名的用户等情况 1SELECT 1 FROM user WHERE country = &apos;China&apos; LIMIT 1 5.千万不要ORDER BY RAND()6. 请不要使用SELECT *使用SELECT *的弊端有两点： 1.需要什么字段就查询什么字段，这样可以不需要遍历所有列2.可以减少网络传输中不必要的数据 7.建议给每张表建一个自增长的主键ID最好给每张表建一个为ID的主键列，查询，排序时会十分方便，如果知道数据量不大，ID的类型可以为SMALLINT或者更小的无符号类型 8.尽量使用NOT NULL我们开发过程中最讨厌的就是空指针异常了，因为他真的防不胜防，所以请尽量给每一个字段加上NOT NULL，有需要的请加上默认值 9.把IP地址存成 UNSIGNED INT很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。 10.设计表的时候请垂直分割“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，不仅可以加快处理速度，也可减少数据冗余，从而达到优化的目的。 11.请拆分大的连接语句之前见过同事写的连接语句，把编译器整整暂满了10行，看起来简直蛋疼。请拆分你的连接语句，不仅可以提高执行效率而且分段查询可以减少因行锁而产生的死锁问题 12.选择正确的存储引擎MySql的存储引擎有两种：MyISAM、InnoDB 1.MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。 2.InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 13.尽量少使用连接查询避免少使用连接查询，虽然有的同学说多次查询会增加连接次数，但是也有一个很有利的优点就是单个查询语句可以利用缓存，所以合理的拆分你的连接语句可以大大提高执行效率","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lilei644.github.io/tags/mysql/"}]},{"title":"手把手教你绘制Android粘性果冻动画组件","slug":"AndroidSpringAction","date":"2016-12-06T12:46:30.000Z","updated":"2018-01-04T03:12:11.727Z","comments":true,"path":"2016/12/06/AndroidSpringAction/","link":"","permalink":"https://lilei644.github.io/2016/12/06/AndroidSpringAction/","excerpt":"利用阻尼函数以及ValueAnimator通过贝塞尔曲线绘制弹性动画的组件 引言 从事移动互联网开发已经快两年了，回想当初是Android带我走进了移动端的世界，后来由于自身对用户体验比较感兴趣，发现iOS更注重对图形渲染以及动画处理，所以转身自学iOS开发，之后也发布了几个iOS的组件库。但是Android进两年发展趋势猛增，在动画处理上也比以前有所改进，Android3.0之后开启了GPU硬件加速让图形渲染没以前那么卡顿，特别是5.0之后的material design更是引领潮流。所以趁最近工作不忙有时间，写了个弹性动画的ActionMenu，核心原理来自咱们iOS界有动画小王子之称的kittenyang的这篇博客（特此鸣谢），废话不多说了，先上效果图（gif存在失真，实际效果更佳流畅Q弹）。","text":"利用阻尼函数以及ValueAnimator通过贝塞尔曲线绘制弹性动画的组件 引言 从事移动互联网开发已经快两年了，回想当初是Android带我走进了移动端的世界，后来由于自身对用户体验比较感兴趣，发现iOS更注重对图形渲染以及动画处理，所以转身自学iOS开发，之后也发布了几个iOS的组件库。但是Android进两年发展趋势猛增，在动画处理上也比以前有所改进，Android3.0之后开启了GPU硬件加速让图形渲染没以前那么卡顿，特别是5.0之后的material design更是引领潮流。所以趁最近工作不忙有时间，写了个弹性动画的ActionMenu，核心原理来自咱们iOS界有动画小王子之称的kittenyang的这篇博客（特此鸣谢），废话不多说了，先上效果图（gif存在失真，实际效果更佳流畅Q弹）。 核心原理主要知识点其实就下面三项 Android自定义View以及ViewGroup 利用三阶贝塞尔曲线绘制图形 通过ValueAnimator结合阻尼振动自定义属性变化 各项讲解Android自定义View以及ViewGroup首先我们先做出一个圆形的弹性动画效果，先得自定义一个view，然后重写onDraw可以用过path和paint任意绘制图形，具体细节我就不多说了，不了解的同学可以查阅相关资料学习。 利用三阶贝塞尔曲线绘制图形贝塞尔曲线是我认为一个比较神奇的东西，因为他基本上可以绘制出任何图形，有兴趣的同学可以到这个网站玩一下，那么我们今天需要做的就是用三阶贝塞尔曲线画圆图中以A,B,C,D四个点作为基准点，把一个圆分4次绘制，以c1-c8作为四次绘制中三阶贝塞尔曲线的辅助点，各点的位置我们设为offSet，由前辈们计算，当offSet为（圆形直径/3.6）时刚好是一个整圆，后来找到一篇文章介绍了其原理（虽然我看完之后还是一脸懵逼）。我们设置形变系数为factor（0~1），设定圆形拉伸的最大程度为圆形的2/5， 则extra= circleRadius2factor/5，分别列出各点坐标123456789101112131415intxA =0,xB =0,xC =0,xD =0,yA =0,yB =0,yC =0,yD =0;xA =circleRadius;xB =circleRadius*2+extra;xC =circleRadius;xD =0;yA =extra;yB =circleRadius;yC =circleRadius*2-extra;yD =circleRadius;offSet=circleRadius*2/3.6f;mPath.moveTo(xA,yA);mPath.cubicTo(xA +offSet,yA,xB,yB -offSet,xB,yB);mPath.cubicTo(xB,yB +offSet,xC +offSet,yC,xC,yC);mPath.cubicTo(xC -offSet,yC,xD,yD +offSet,xD,yD);mPath.cubicTo(xD,yD -offSet,xA -offSet,yA,xA,yA); OK！基本点都绘制完了，直接Run起来看到一个红通通的圆形绘制成功之后第一部大功告成！ 通过ValueAnimator结合阻尼振动自定义属性变化上面我们已经绘制好了一个圆形，接下来事情就很简单了，只需要通过改变形变系数factor（0~1）的值来改变形变程度就可以了，下面介绍一个Android的动画API—ValueAnimator，直接通过组件属性定义的动画效果，然后重写变化机制1234ValueAnimator valueAnimator = ValueAnimator.ofObject(new FloatEvaluator(time,1,0),1,0);valueAnimator.addUpdateListener(this);valueAnimator.setDuration(time);valueAnimator.start(); 12345@Overridepublic voidonAnimationUpdate(ValueAnimator animation) &#123; factor= (float)animation.getAnimatedValue(); invalidate();&#125; 由此原理就是通过属性动画不断的改变factor从1到0，然后刷新重绘小圆球，FloatEvaluator就是我们自定义的根据什么样的函数去改变factor，这个时候就要介绍到我们高中学习的阻尼振动函数了 该函数可以模拟最真实的弹性效果我们60帧为基准（肉眼看到刷新流畅度的最低标准），计算出一列变化factor的值12345678910publicFloatEvaluator(longtime, floatstartValue, floatendValue) &#123; sum= (int)time *60/1000; float diff = endValue - startValue; value=new float[sum]; float x; for(int i = 0; i &lt; sum; i++) &#123; x = i *1.0f/sum; value[i] = endValue - (float)(diff * Math.pow(Math.E,-1*dampingFactor* x) * Math.cos(velocityFactor* x)); &#125;&#125; 其中dampingFactor和velocityFactor为阻力和速度，我这里设置的是5和30，可以自定义调节改变弹性程度。 基本构建完成，添加一个按钮启动动画试试效果 大功告成！ 总结大家掌握了一个圆形组件的形变原理之后剩下的就容易多了，利用ViewGroup多绘制几个摆摆位置就OK了，也可以利用这种原理自己创新构思出别的控件，只要掌握了核心的两点： 贝塞尔曲线绘制图形 利用阻尼函数以及ValueAnimator自定义形变属性的值 最后贴上源码地址，有兴趣的同学欢迎star，共同学习探讨动画知识！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://lilei644.github.io/tags/Android/"},{"name":"animation","slug":"animation","permalink":"https://lilei644.github.io/tags/animation/"}]},{"title":"使用Hexo + Github搭建个人博客","slug":"hello-world","date":"2016-01-04T03:01:58.000Z","updated":"2018-01-04T03:07:21.414Z","comments":true,"path":"2016/01/04/hello-world/","link":"","permalink":"https://lilei644.github.io/2016/01/04/hello-world/","excerpt":"Welcome to Hexo! 博客是大多数技术人员用来记录开发经验的方式，下面我们使用Hexo + Github建立个人静态博客。 环境配置安装Node.js点击进入Node.js官网下载安装包,mac也可使用homebrew直接构建环境 打开终端使用node –version查看是否安装成功","text":"Welcome to Hexo! 博客是大多数技术人员用来记录开发经验的方式，下面我们使用Hexo + Github建立个人静态博客。 环境配置安装Node.js点击进入Node.js官网下载安装包,mac也可使用homebrew直接构建环境 打开终端使用node –version查看是否安装成功 安装Git点击进入Git官网配置git环境 同样使用git –version查看是否安装成功 安装Hexo点击进入Hexo官网，由于已经安装好node，所以终端直接使用 1npm install hexo-cli -g 同样使用hexo –version查看版本号即可知道是否安装成功 创建仓库新建github项目 项目命名为yourname.github.io即可（yourname为你想使用的名字） hexo创建博客环境 终端cd到存储的文件夹下 初始化 12hexo init npm install hexo-deployer-git --save 执行本地测试 1hexo server 执行后打开本地网页localhost:4000即可看到网页 修改配置文件_config.yml（配置github上的git地址） 1234deploy: type: git repository: https://github.com/xxx/xxx.github.io.git branch: master 提交上传 123hexo cleanhexo ghexo d 上传成功，打开网址https://xxx.github.io即可看到自己的个人博客网页 OK!下面就愉快的使用Markdown写博客吧 博客主题 如果觉得hexo默认的博客主题不喜欢，可以github上搜索相关的开源主题，下面贴出本博客的主题地址","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lilei644.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://lilei644.github.io/tags/blog/"}]}]}